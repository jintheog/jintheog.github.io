---
title: "INDEX"
date: 2025-10-27 14:00:00 +0900
categories: [Database, SQL]
tags: [sql, database]
---

# 뷰(View): 하나 이상의 테이블로부터 유도된 가상 테이블(Virtual Table)

- 가상: 실제 데이터를 저장하지 않음 (쿼리 정의만 저장)
- 동적결과: 뷰를 조회할 때마다 기본 테이블에서 데이터를 가져옴
- 재사용성: 복잡한 쿼리를 뷰로 만들어 반복 사용
- 보안: 특정 컬럼/행만 노출하여 데이터 접근 제어
- 독립성: 기본 테이블 구조 변경 시 뷰가 변경 영향 완화

# 기본 view 생성 구문

```sql
CREATE VIEW 뷰이름 AS
SELECT 쿼리;

```

```sql
-- 복잡한 JOIN 쿼리를 매번 작성하는 대신...
SELECT c.Name AS Country, ci.Name AS City, ci.Population
FROM country c
JOIN city ci ON c.Code = ci.CountryCode
WHERE c.Continent = 'Asia'
ORDER BY ci.Population DESC;

-- 뷰로 만들어 간단하게 사용
CREATE VIEW asian_cities AS
SELECT c.Name AS Country, ci.Name AS City, ci.Population
FROM country c
JOIN city ci ON c.Code = ci.CountryCode
WHERE c.Continent = 'Asia';

-- 사용
SELECT * FROM asian_cities ORDER BY Population DESC LIMIT 10;
```

### 보안

```sql
-- 급여 정보를 제외한 뷰 생성
CREATE VIEW employee_public AS
SELECT employee_id, name, department, hire_date
FROM employees;
-- salary 컬럼은 제외

-- 일반 사용자에게는 뷰만 접근 권한 부여
GRANT SELECT ON employee_public TO general_user;

```

### 데이터 독립성

```sql
-- 테이블 구조가 변경되어도 뷰를 통해 일관된 인터페이스 제공
CREATE VIEW customer_summary AS
SELECT
    customer_id,
    CONCAT(first_name, ' ', last_name) AS full_name,
    email
FROM customers;
```

### 복잡한 비지니스 로직 캡슐화

```sql
-- 고객 등급 계산 로직을 뷰로 캡슐화
CREATE VIEW customer_tier AS
SELECT
    customer_id,
    total_spent,
    CASE
        WHEN total_spent >= 10000 THEN 'VIP'
        WHEN total_spent >= 5000 THEN 'Gold'
        WHEN total_spent >= 1000 THEN 'Silver'
        ELSE 'Bronze'
    END AS tier
FROM (
    SELECT customer_id, SUM(amount) AS total_spent
    FROM payments
    GROUP BY customer_id
) AS customer_totals;

```
